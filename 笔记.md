## mongoose使用

connect连接数据库

定义文档模型，Schema和model新建模型

代一个数据库文档对应一个模型，通过模型对数据库进行操作

## mongoose文档

**文档类型**

String, Number等数据结构
定create, remove, update分别用来增、删、改的操作
find和findOne用来查询数据

**增删改查**

mongod --config /usr/local/etc/mongod.conf 后台启动
express结合mongodb
封装mongoose

```js
const User = mongoose.model('user', new mongoose.Schema({
  username: {type: String, require: true},
  age: {type: Number, require: true}
}))
```

**Express和mongoDB结合**

mongodb独立工具函数
express使用body-parser支持post参数
使用cookie-parser存储登录信息cookie

## 基础

React 专注view层，构建UI的图

### React声明周期

**First Render**
getDefaultProps
getInitialState
componentWillMount
render
componentDidMount

**Unmount**
componentWillUnmount

**Second Render**
getInitialState
componentWillMount
render
componentDidMount

**Props change**
componentWillReceiveProps
shouldComponentUpdate
componentWillUpdate
render
componentDidUpdate

**State chagne**
shouldComponentUpdate
componentWillUpdate
render
componentDidUpdate

## React编程思想

**步骤1：将 UI 拆解到组件层次结构中**

单一职责原则，拆分更小的组件

**步骤2：用React构建一个静态版本**

React 的 单向数据流（也称为 单向绑定 ）使所有模块化和高性能。
小插曲: Props(属性) vs State(状态)
在 React 中有两种类型的“模型”数据：props(属性) 和 state(状态)。理解这两者的差异非常重要

**步骤3： 确定 UI state(状态) 的最小（但完整）表示**

要正确的构建应用程序，你首先需要考虑你的应用程序需要的可变 state(状态) 的最小集合。这里的关键是：不要重复你自己 (DRY，don’t repeat yourself)。找出你的应用程序所需 state(状态) 的绝对最小表示，并且可以以此计算出你所需的所有其他数据内容。

**步骤4：确定 state(状态) 的位置**

React 单向数据流在层级中自上而下进行。这样有可能不能立即判断出状态属于哪个组件。

对于应用中的每一个state状态，可按以下步骤分析：

1. 确定每个基于这个state渲染的组件
2. 找出公共父组件（一个单独的组件，在组件层级中位于所有需要这个state组件的上面）
3. 公共父级组件或者另一个更高级组件拥有这个state
4. 如果找不出一个拥有该state的合适组件，可以创建一个简单的新组件来保留这个state，并将其添加到公共父级组件的上层即可

**步骤5：添加反向数据流**

目前，构建的应用已经具备了正确渲染 props(属性) 和 state(状态) 沿着层次结构向下传播的功能。现在是时候实现另一种数据流方式：层次结构中深层的 form(表单) 组件需要更新 FilterableProductTable 中的 state(状态) 

